lec 16 ~

14. 게시판
 1) 게시판의 주요기능
 	- 로그인 후 게시물 등록, 수정이 가능하도록 처리 (로그인 한 사용자만 등록, 수정가능)
 	- 글쓰기(스마트에디터 적용, 태그문자 처리, 공백처리, 줄바꿈 처리)
 	- 게시물 상세정보, 조회수 증가 처리
 	- 게시물 수정/ 삭제(delete방식, update방식)
 	- 검색기능
 	- 페이지 나누기
 	
 2) 파일 업로드(ajax)
 	- 게시판에 파일 첨부
 	- 첨부파일 목록, 다운로드, 삭제
 	- 수정화면에서 새로운 파일 올리기
 	
 3) 댓글기능
 	- 일반적인 방식으로 댓글쓰기(RestController, REST방식)
 		> $.ajax()함수 호출하여 insert
 		> 컨트롤러에서 뷰로 포워딩한 responseText를 html 태그에 출력
 	- 컨트롤러에서 ArrayList를 json형식으로 리턴받아 댓글 목록 출력(list_json.do)
 	- 목록에 댓글 갯수 표시
 	- 댓글 페이지 나누기(댓글 목록은 일반적인 방식으로 처리)
 	- 비밀댓글 쓰기, 표시
 	- REST방식으로 댓글 쓰기(insert_rest.do)
 		> 크롬 확장프로그램을 이용한 입력처리
 		> {"replytext":"댓글", "replyer":"kim", "bno":"1", "secret_reply":"n"}
 	- REST방식으로 댓글 목록 출력
 	- REST방식으로 댓글 상세확인, 수정, 삭제 기능 구현
 
 4) 구조개요
  1> 테이블
  	- member : 회원 정보
  	- board : 게시물 정보
  	- reply : 댓글 정보
  	- attach : 첨부파일 정보

 5) 글 목록 보기 구현
  1> 게시판 테이블
  	ORACLE ======================================================================================================
		-- cascade constrains 제약조건까지 모두 삭제
		drop table board cascade constrains;
		
		create table board (
			bno number not null,			--게시물 번호
			title varchar2(200) not null,	--제목
			content clob,					--내용
			writer varchar2(50) not null,	--이름
			regdate date default sysdate,	--날짜
			viewcnt number default 0,		--조회수
			primary key(bno)
		);
		
		-- nvl(A,B) A가 null이면 B, null이 아니면 A
		delete from board;
  	=============================================================================================================
  	
  	MYSQL ======================================================================================================
		/* cascade constrains 제약조건까지 모두 삭제*/
		drop table board cascade constrains;
		
		create table board (
			bno int not null auto_increment,	/*게시물 번호*/
			title varchar(200) not null,		/*제목*/
			content text,						/*내용*/
			writer varchar(50) not null,		/*이름*/
			regdate datetime default now(),		/*날짜*/
			viewcnt int default 0,				/*조회수*/
			primary key(bno)
		);
		
		-- nvl(A,B) A가 null이면 B, null이 아니면 A
		delete from board;
		insert into board (bno, title, content, writer) values(1,'제목','내용','kim');
		select * from board;
  	=============================================================================================================

  2> menu에 추가 : <a href="${path}/board/list.do">게시판</a>
  3> com.example.spring02.model.board.dto : BoardDTO.java
  	------------------------------------------------------------------------------------------------------------
		public class BoardDTO {
			// board테이블과 동일한 부분
			private int bno;
			private String title;
			private String content;
			private String writer;		//작성자 id
			private Date regdate;		//java.util.Date
			private int viewcnt;		//조회수
			
			// 테이블에 없는 필드 : join하여 가져올 값
			private String name;		//작성자 이름
			private int cnt;			//댓글 갯수
			private String show;		//화면 표시 여부
			// 첨부파일 테이블을 따로 작성
			private String[] files;		//첨부파일 이름배열
			
			... getter/setter/toString
		}
  	------------------------------------------------------------------------------------------------------------

  4> 댓글, 첨부파일 테이블
  	- 댓글 테이블
  	ORACLE ======================================================================================================
		create table reply (
			rno number not null primary key,	--댓글 번호
			bno number default 0,				--글 번호
			replytext varchar2(1000) not null,	--댓글 내용
			replyer varchar2(50) not null,		--댓글 작성자
			regdate date default sysdate,		--댓글 등록시간
			updatedate date default sysdate		--댓글 수정시간
		);
		
		-- bno 필드에 foreign key 설정
		alter table reply add constraint fk_board foreign key(bno) references board(bno);
		
		-- 시퀀스 생성
		create sequence reply_seq start with 1 increment by 1;
		
		insert into reply(rno,bno,replytext,replyer) values(reply_seq.nextval, 1, '댓글...', 'kim');
  	=============================================================================================================
  	MYSQL ======================================================================================================
		create table reply (
			rno int not null primary key auto_increment, /*댓글 번호 ORACLE의 시퀀스 = AUTO_INCREMENT */
			bno int default 0,					/*글 번호*/
			replytext varchar(1000) not null,	/*댓글 내용*/
			replyer varchar(50) not null,		/*댓글 작성자*/
			regdate datetime default now(),		/*댓글 작성시간*/
			updatedate datetime default now()	/*댓글 수정시간*/
		);
		
		/* bno 필드에 foreign key 설정 : add constraint 제약조건이름 foreign key(필드명) references 테이블(필드)*/
		alter table reply add constraint fk_board foreign key(bno) references board(bno);
		
		/*서브쿼리 : select ifnull(max(rno)+1,1) from reply a */
		insert into reply(rno,bno,replytext,replyer) 
			values((select ifnull(max(rno)+1,1) from reply a), 1, '댓글...', 'kim');
  	=============================================================================================================

  	- 첨부파일 테이블
  	ORACLE ======================================================================================================
		create table attach(
			fullName varchar2(150) not null, 	--첨부파일 이름
			bno number not null,				--board 테이블의 글번호
			regdate date default sysdate,
			primary key(fullName)				--파일 이름에 uuid가 붙어 있어 중복x
		);
		
		--foreign key설정
		alter table attach add constraint fk_board_attach foreign key(bno) references board(bno);
  	=============================================================================================================
  	MYSQL ======================================================================================================
		create table attach(
			fullName varchar(150) not null,		/*첨부파일 이름*/
			bno int not null,					/*board테이블의 글번호*/
			regdate datetime default now(),
			primary key(fullName)				/*파일 이름에 uuid가 붙어 있어 중복x*/
		);
		
		/*foreign key설정*/
		alter table attach add constraint fk_board_attach foreign key(bno) references board(bno);
  	=============================================================================================================

  5> com.example.spring02.model.board.dto : ReplyDTO.java
  6> com.example.spring02.model.board.dao : BoardDAO.java, BoardDAOImpl.java
  	- 게시물 목록 리턴 : listAll()
		> selectList("namespace.id") : 레코드가 2개 이상
		> selectOne() : 레코드가 1개

  7> boardMapper.xml작성
  8> com.example.spring02.service.board : BoardService.java, BoardServiceImpl.java
  9> com.example.spring02.controller.board : BoardController.java
  	- BoardController ==> BoardService ==> BoardDAO ==> boardMapper.xml
  	- HashMap<>() : 여러 데이터를 한번에 묶어 전송가능

  10> views/board/list.jsp작성
  	- map으로 넘어온 내용 {"count"=val, "list"=val{...} }
  	
  11> 목록 화면에서 id대신 이름 출력
>>	- boardMapper.xml의 listAll query 수정
	 -----------------------------------------------------------------------------------------------------------
	 select bno, title, writer, name, regdate, viewcnt 
	 	from board b, member m 		/*테이블 join*/ 
	 	where b.writer=m.userid 	/*게시판 테이블의 writer와 멤버 테이블의 userid가 일치하는것*/
	 	order by bno desc;
	 -----------------------------------------------------------------------------------------------------------

 6) 글쓰기 기능
 	- 회원제 게시판 : 로그인한 사용자에게만 기능을 열어줌
 	- list.jsp 수정 : button을 눌러 글쓰기 화면으로 이동
  1> controller : write()
  2> views/board/write.jsp
  3> 로그인 체크기능 : 회원제 기능을 위한 로그인 체크
  	- sol 1. 화면에서 버튼을 숨김
  		> 세션변수를 확인하여 버튼을 보여주거나 숨김 <c:if test="${sessionScope.userid != null}">
  		> 주소를 직접 입력하면 화면으로 이동가능
  			- 컨트롤러에서도 세션값을 받아 처리하여야 함
				-----------------------------------------------------------------------------------------------
					// sol1. 세션체크하여 로그인여부에 따라 분기
					@RequestMapping("write.do")
					public String write(HttpSession session) {
						if(session.getAttribute("userid") == null) {
							return "member/login";
						}
						// 글쓰기 폼 페이지로 이동
								return "board/write";
					}
				-----------------------------------------------------------------------------------------------
		> --> 화면과 컨트롤러에서 두번 확인하여야 함.
	
	- sol 2. 인터셉터 사용
		> 요청이 들어왔을 때 인터셉터에서 확인 후 컨트롤러로 넘김
			- /board/write.do --> LoginInterceptor(preHandle()) --> BoardController
			
		> servlet-context.xml에 정의한 loginInterceptor를 사용 (코드는 기 작성한 interceptor패키지 참조)
			===================================================================================================
			<!-- 인터셉터 빈을 등록 : class에 전체경로 작성, id는 이 bean을 참조할 변수명 --> 
			<beans:bean id="loginInterceptor" class="com.example.spring02.interceptor.LoginInterceptor"></beans:bean>
			
			<!-- 인터셉터 호출을 위한 url mapping -->
			<!-- beans:ref bean="참조할 bean의 id" -->
			<interceptor>
				<mapping path="/board/write.do" />
				<mapping path="/board/insert.do" />
				<mapping path="/board/update.do" />
				<mapping path="/board/delete.do" />
			</interceptor>
			===================================================================================================

		> interceptor.LoginInterceptor
			===================================================================================================
			// HandlerInterceptorAdapter 추상클래스 상속
			// preHandle(), postHandle() 오버라이딩
			public class LoginInterceptor extends HandlerInterceptorAdapter{
				
				// 메인액션이 실행되기 전
				@Override
				public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
						throws Exception {
					// 세션 객체 생성
					HttpSession session = request.getSession();
					// 세션이 없으면 = 로그인 되지 않은 상태
					if(session.getAttribute("userid") == null) {
						// 로그인 페이지로 이동
						response.sendRedirect(request.getContextPath() + "/member/login.do?message=nologin");
						// 메인 액션으로 돌아가지 않음.
						return false; 
					} else {
						// 메인액션으로 이동
						return true;
					}
				}
			}
			===================================================================================================

  4> controller : insert()
  	===========================================================================================================
		// write.jsp에서 입력한 내용들이 BoardDTO에 저장됨
		@RequestMapping("insert.do")
		// @ModelAttribute 생략가능
		public String insert(@ModelAttribute BoardDTO dto, HttpSession session) throws Exception{
			// 세션에서 사용자 아이디를 가져옴 
			//		: 화면에서 넘겨주는 폼 데이터에는 아이디가 없음. 저장을 위해서 세션에서 받아야 한다.
			String writer = (String)session.getAttribute("userid");
			dto.setWriter(writer);
			// 레코드 저장
			boardService.create(dto);
			// 게시물 목록으로 이동
			return "redirect:/board/list.do";
		}
  	===========================================================================================================
  
  5> service, model(dao) : create() --> create()
  6> mapper
  	===========================================================================================================
  		<insert id="insert">
			insert into board(bno,title,content,writer)
				values((select ifnull(max(bno)+1,1) from board a), #{title}, #{content}, #{writer})
		</insert>
  	===========================================================================================================

 7) 글쓰기 페이지 파일첨부 기능 - drag&drop
  1> write.jsp : script 추가
	===========================================================================================================
		<!-- 페이지에서 사용할 javascript 메서드 -->
		<script src="${path }/include/js/common.js"></script>
		
		<script type="text/javascript">
		$(function(){
			$("#btnSave").click(function(){
				var str = "";
				// uploadedList 내부의 .file 태그를 각각 반복
				$("#uploadedList .file").each(function(i) { // i=index 해당하는 태그 목록의 순서대로 index 생성
					//hidden 태그 수정하여 추가. 
					//$(this) = 현재 작업중인 태그
					str += "<input type='hidden' name='files["+i+"]' value='" + $(this).val() +"'>";	
				});
				// 폼에 hidden 태그들을 붙여 폼의 정보(제목, 내용)와 같이 hidden 태그를 전송
				$("#form1").append(str);
				document.form1.submit();
			});
			
			$(".fileDrop").on("dragenter dragover", function(e){
				//기본효과 막음 : drop의 기본효과 = 해당 파일을 브라우저에서 보여줌
				e.preventDefault();
			});
		
			$(".fileDrop").on("drop", function(e){
				//기본효과 막음
				e.preventDefault();
				//첫번째 첨부파일 : 다중업로드 불가
				var files = e.originalEvent.dataTransfer.files;
				var file = files[0];
				//폼 데이터에 첨부파일 추가
				var formData = new FormData();
				formData.append("file", file);
				$.ajax({
					url: "${path}/upload/uploadAjax",
					data: formData,
					dataType: "text", // 웹에서 정보를 넘기므로 text형태로 넘김
					processData: false,	// 진행률 옵션
					contentType: false,
					type: "post",
					success: function(data) {
						console.log(data);
						//data : 업로드한 파일 정보, http상태코드
						var fileInfo = getFileInfo(data);
						console.log(fileInfo);
						var html = "<a href='" +fileInfo.getLink+"'>" + fileInfo.fileName+"</a><br>";
						
						// hidden tag생성
						html += "<input type = 'hidden' class='file' value='" + fileInfo.fullName+ "'>";
						$("#uploadedList").append(html);
					}
				});
			});
		});
		</script>
	===========================================================================================================
		> AjaxUploadController에서 처리. (이전 예제에서 구현한 코드 사용. )
		> 사용할 메서드를 따로 file로 만들어 사용

>> **lec 16 1:28:55 파일첨부 기능구현 설명	
		> 확인 버튼을 눌렀을 때, 첨부된 파일의 정보는 첨부파일 테이블에 저장되도록 기능 구현
		> 전송버튼을 눌렀을 때, drop시 만들어진 hidden tag를 찾아 form 태그에 내용을 바꾸어 추가.
		> boardController로 데이터가 넘어가 files필드에 hidden tag의 name(files[0]등)에 따라 value가 배열로 저장됨

  2> BoardServiceImpl : create()
  	- 컨트롤러에서 받은 dto정보를 각각의 테이블에 저장
  	- board table에 레코드 추가 : boardDao.create(dto)
  	- attach table에 첨부파일 레코드 추가 : boardDao.addAttach(dto);
  	===========================================================================================================
		// 하나의 메서드에 두가지 동작 --> 트랜젝션 처리 필요
		//1. 글쓰기 - 게시물 번호 생성
		//2. 첨부파일 등록 - 게시물 번호 사용
		@Transactional
		@Override
		public void create(BoardDTO dto) throws Exception {
			//board 테이블에 레코드 추가
			boardDao.create(dto);
			
			//attach 테이블에 레코드 추가
			String[] files = dto.getFiles();
			if(files == null) return; //첨부파일이 없으면 skip
			for(String name : files) {
				boardDao.addAttach(name); // attach 테이블에 insert
			}
		}
  	===========================================================================================================
  		> 하나의 서비스에 두가지 동작이 발생 --> 트랜잭션 처리 필요.

  3> BoardDAOImpl : addAttach()
  4> boardMapper
  	===========================================================================================================
	<insert id="addAttach">
		insert into attach(fullName, bno) values (#{fullName}, (select ifnull(max(bno),1) from board a))
	</insert>
  	===========================================================================================================
	- select ifnull(max(bno)) from board a 
		: service에서 board테이블에 레코드를 추가 후 attach테이블에 레코드를 추가 하므로,
	 	현재 작업중인 레코드 번호는 제일 마지막 번호가 된다.

>> lec 16 종료.
>> lec 17

  5> 글쓰기 페이지 스마트 에디터 적용 : write.jsp
  	===========================================================================================================
	<!-- CKEditor -->
	<script src="${path }/ckeditor/ckeditor.js"></script>
	
	<script>
		$(function(){
			//CKEDTOR적용
			CKEDITOR.replace("content", {
				//파일업로드를 처리할 주소
				filebrowserUploadUrl: "${path}/imageUpload.do"
			});
		});
	</script>
  	===========================================================================================================

 2) 페이지 나누기
  1> 페이지 / 페이지 블록 계산
 	- 페이지당 게시물 수 : 10개
 	- 전체 게시물 수 : 991개
 	- 페이지 계산 : 991/10 = 99.1올림 ==> 100
 	
 	- 페이지의 시작번호, 끝번호 계산
 		> where rn between 1 and 10
 		> 1페이지 = 1~10 / 2페이지 = 11~20 ... 99페이지 = 981~990
 	
 	- 시작번호 = (현재페이지 - 1) * 페이지 당 게시물 수 + 1 
 		> 2페이지 = (2-1) * 10 + 1 ==> 11
 		> 7페이지 = (7-1) * 10 + 1 ==> 61
 	
 	- 끝번호 = 시작번호 + 페이지당 게시물 수 - 1
 		> 1페이지 = 1 + 10 - 1 ==> 10
 		> 2페이지 = 11 + 10 - 1 ==> 20
 		
 	- 전체 페이지 블록 수 = 전체 페이지 갯수 / 10
 		> 91/10 ==> 9.1 => 10개
 		
 	- 현재 페이지가 속한 블록 = (현재 페이지 - 1) / 페이지 블록단위 + 1
 		> 1페이지 ==> (1-1)/10 + 1 --> 1 
 		> 9페이지 ==> (9-1)/10 + 1 --> 1
 		> 57페이지 ==> (57-1)/10 + 1 --> 6
 	
 	- 페이지 블록의 시작번호 = (현재블록 - 1) * 블록단위 + 1
 		> 1블록 ==> (1-1)*10 + 1 ==> 1
 		> 2블록 ==> (2-1)*10 + 1 ==> 11
 		
 	- 페이지 블록의 끝번호 = 블록 시작번호 + 블록단위 - 1
		> 1블록 ==> 1 + 10 - 1 ==> 10
		> 2블록 ==> 11 + 10 - 1 ==> 20
		> 6블록 ==> 51 + 10 - 1 ==> 60

	- 페이지 표시
		=======================================================================================================
		ex) 11페이지
		
		> 화면 : [이전] 11 12 13 ... 20 [다음]
		
		> 몇번째 블록인지 계산
			- (현재페이지 -1 ) / 페이지 블록단위 +1 : (11 - 1) / 10 + 1 = 2번째 블록 (몇페이지 ~ 몇페이지)
		> 해당 블록의 첫번째 페이지 계산
			- (현재블록 - 1) * 블록단위 + 1 : (2-1)*10 + 1 = 11페이지
		=======================================================================================================

  2> 테이블 정리
  	- 게시물 1000개 입력
  		OARCLE ================================================================================================
			declare
				i number := 1;
			begin
				while 1<=1000 loop
					insert into board (bno, title, content, writer) 
						values((select nvl(max(bno)+1,1) from board), '제목'||i, '내용'||i, 'kim');
					i := i+1;
				end loop;
			end;
			/
			select count(*) from board;
			select * from board;
  		=======================================================================================================
  		MYSQL =================================================================================================
  		**ALTER TABLE `attach` DROP FOREIGN KEY `fk_board_attach`;
  		
  		**plsql
			delimiter $$
	
			DROP PROCEDURE IF EXISTS spring.datatest$$
			
			CREATE PROCEDURE spring.datatest(idx INT)
			
			BEGIN
				DECLARE i INT DEFAULT 1;
				while i<=idx do
					insert into board (bno, title, content, writer) 
						values((select ifnull(max(bno)+1,1) from board a), (concat('제목',i)), (concat('내용',i)), 'kim');
					set i = i+1;
				END while;
			END $$;
			
			delimiter;
			
			CALL spring.datatest(997);
  		=======================================================================================================

>>	- select query 수정
		> 전체 레코드를 조회하고, 결과를 임시테이블에 넣고 레코드에 일련번호를 매긴 후 필요한 부분을 출력.
		ORACLE ================================================================================================
			-- rownum : 출력순서
			select *
			from (
				/*해당 select로 출력되는 모든 레코드를 A라는 테이블로 정의 + rownum(일련번호)*/
				select rownum as rn, A.*
				from (
					/* 전체 레코드를 불러오는 query */
					select bno, title, writer, name, regdate, viewcnt 
				 	from board b, member m
				 	where b.writer=m.userid
				 	order by bno desc
			 	) A
			) where rn between 1 and 10;
		=======================================================================================================

		MYSQL ================================================================================================
		** MYSQL의 모든 서브쿼리는 alias가 필요하다. EX) select * from board b... --> b 가 alias
			SELECT R.*
			from (
				/*해당 select로 출력되는 모든 레코드를 A라는 테이블로 정의 + @rownum(일련번호 변수)*/
				SELECT @rownum:=@rownum+1 AS rn, A.*
				from (
					/* 전체 레코드를 불러오는 query */
					select bno, title, writer, name, regdate, viewcnt 
				 	from board b, member m
				 	where b.writer=m.userid
				 	order by bno desc
			 	) A, /* 검색된 내용 --> 임시테이블의 형태를 가짐. alias로 테이블의 이름을 부여 */
			 	(SELECT @rownum:=0) N /* 서브쿼리로 변수 초기화 */
			) R WHERE R.rn BETWEEN #{start} AND #{end}
		=======================================================================================================

  3> 페이저 클래스 작성
  	- service.board : Pager.java
  		> 각 변수, 페이지/블록의 계산 메소드 작성
  
  4> controller 수정 : list.do
  	=========================================================================================================
		@RequestMapping("list.do")	// 세부적인 url pattern
		public ModelAndView list(@RequestParam(defaultValue="1") int curPage) throws Exception {
			//레코드 갯수 계산
			int count = boardService.countArticle();
			//페이지 관련 설정
			Pager pager = new Pager(count, curPage);
			int start =  pager.getPageBegin();
			int end = pager.getPageEnd();
			
			List<BoardDTO> list = boardService.listAll(start, end);	// 게시물 목록
			ModelAndView mav = new ModelAndView();
			HashMap<String, Object> map = new HashMap<>();
			
			map.put("list", list);		// map에 자료 저장
			map.put("count", count);	// 게시물 총 갯수
			
			map.put("pager", pager);	// 페이지 네비게이션을 위한 변수
			
			mav.setViewName("board/list"); // 포워딩할 view의 이름
			mav.addObject("map", map);	//ModelAndView에 map을 저장
			
			return mav; // board/list.jsp로 이동
		}
  	=========================================================================================================
	- 레코드 총 갯수 필요		
		> service, model(dao) 작성 : countArticle(), return 값 int
		> mapper 작성
			==================================================================================================
			  	<select id = "countArticle" resultType="int">
					select count(*) from board
				</select>
			==================================================================================================
	- 요청에 따라 페이지가 바뀌어야 하므로, 매개변수값을 받도록 추가한다.
	
	- boardService와 boardDao의 listAll을 매개변수(start, end)가 들어간 메소드로 수정
		> 인터페이스와 메소드 모두 매개변수를 받아 전달하도록 수정
		> DAOImpl에서는 sqlSession의 함수인 selectList()가 여러개의 매개변수를 전달 할 수 없음
			--> dto나 map으로 묶어 전달.
			==================================================================================================
				// 게시물 목록 리턴
				@Override
				public List<BoardDTO> listAll(int start, int end) throws Exception {
					// Map<key의 자료형, value의 자료형>
					Map<String, Object> map = new HashMap<>();
					map.put("start", start);
					map.put("end", end);
					// mapper에는 2개 이상의 값을 전달 할 수 없음(dto또는 map사용)
					return sqlSession.selectList("board.listAll", map);
				}
			==================================================================================================
		> mapper에 map으로 값이 전달 : 속성에 parameterMap설정으로 받을 수 있고, 생략가능하다.

	- 매개값을 넣어 작동 test : http://localhost:8080/spring02/board/list.do?curPage=10
	
  5> 화면 하단에 페이지 번호 추가 : views/board/list.jsp
  	=========================================================================================================
		<!-- 페이지 네비게이션 출력 -->
		<tr>
			<td colspan = "5" align="center">
				<!-- [처음] : 첫번째 블록인 경우 표시되지 않음-->
				<c:if test="${map.pager.curPage > 1 }">
					<a href="#" onclick="list('1')">[처음]</a>
				</c:if>
	
				<!-- [이전] : 첫번째 블록인 경우 표시되지 않음-->
				<c:if test="${map.pager.curBlock > 1 }">
					<a href="#" onclick="list('${map.pager.prevPage}')">[이전]</a>
				</c:if>
				
				<!-- forEach var="개별데이터" begin="시작" end="끝" : 횟수가 고정적-->
				<c:forEach var="num" begin="${map.pager.blockBegin }" end="${map.pager.blockEnd }">
					<c:choose>
						<c:when test="${num == map.pager.curPage }">
							<!-- 현재 페이지인 경우 숫자만 출력하고 색을 넣어 현재페이지 표시 -->
							<span style="color:red;">${num }</span>
						</c:when>
						<c:otherwise>
							<a href="#" onclick="list('${num}')">${num }</a>
						</c:otherwise>
					</c:choose>
				</c:forEach>
				
				<!-- [다음] : 마지막 블록인 경우 표시되지 않음-->
				<c:if test="${map.pager.curBlock < map.pager.totBlock}">
					<a href="#" onclick="list('${map.pager.nextPage}')">[다음]</a>
				</c:if>
	
				<!-- [끝] : 마지막 블록인 경우 표시되지 않음-->
				<c:if test="${map.pager.curPage < map.pager.totPage}">
					<a href="#" onclick="list('${map.pager.totPage}')">[끝]</a>
				</c:if>
			</td>
		</tr>
		...
		<script>
			...
			function list(page){
				location.href = "${path}/board/list.do?curPage="+page;
			}
		</script>
  	=========================================================================================================
	- forEach 용법
		> c:forEach var="개별데이터" begin="시작" end="끝" : 횟수가 고정적
		> c:foreach var="개별데이터" items="집합데이터" : 횟수가 가변적
	- hyper link로 연결되지 않고 이벤트 실행 : java script function 추가

>>lec 17 1:14:00 ~

 3) 상세페이지
 	- 상세페이지 화면을 보면 조회수 증가
 	
  1> list.jsp : 목록의 각 항목의 제목을 하이퍼링크로 처리
  2> controller : view.do
  	=========================================================================================================
		@RequestMapping("view.do")
		public ModelAndView view(int bno, HttpSession session) throws Exception{
			// 조회수 증가 처리
			boardService.increaseViewcnt(bno, session);
			ModelAndView mav = new ModelAndView();
			mav.setViewName("board/view");	//포워딩할 뷰의 이름
			mav.addObject("dto", boardService.read(bno));	// 해당 게시물을 가져와 자료 저장
			return mav; // views/board/view.jsp로 넘어가서 출력됨
		}  
  	=========================================================================================================
	- session 값을 service로 전달 : 일정 시간안에 조회된 수 만큼만 증가하도록 처리
	
	- 조회수 증가 처리
		> service : increaseViewcnt(int bno, HttpSession session)
			- 연속으로 조회수 증가되지 않도록 시간제한 설정 : 5초에 한번 조회수 증가되도록 작성.
			------------------------------------------------------------------------------------------------
				//조회수 증가 처리
				// session을 이용하여 조회수 증가 제한
				@Override
				public void increaseViewcnt(int bno, HttpSession session) throws Exception {
					long update_time = 0;
					if(session.getAttribute("update_time_"+bno) != null) {
						// 최근에 조회수를 올린 시간
						update_time = (long)session.getAttribute("update_time_"+bno);
					}
					long current_time = System.currentTimeMillis();
					// 일정시간이 경과한 후 조회수 증가처리
					if(current_time - update_time > 5*1000)	{
						// 조회수 증가 처리
						boardDao.increateViewcnt(bno);
						// 조회수를 올린 시간 저장
						session.setAttribute("update_time_"+bno, current_time);
					}
				}
			-------------------------------------------------------------------------------------------------
  		> dao : increaseViewcnt(int bno)
  		> mapper
  			-------------------------------------------------------------------------------------------------
			<update id="increaseViewcnt">
				update board set viewcnt = viewcnt+1 where bno=#{bno}
			</update>
  			-------------------------------------------------------------------------------------------------
	
	- 게시물 번호를 매개값으로 해당 게시물 가져오기 : boardService.read(bno)
  		> service : read(bno)
  		> dao : read(bno)
  		> mapper : select id="read"
  			-------------------------------------------------------------------------------------------------
			<select id="read" resultType="com.example.spring02.model.board.dto.BoardDTO">
				select bno, title, regdate, content, viewcnt, name, writer
					 from board b, member m
					 where b.writer=m.userid and bno=#{bno}
			</select>
  			-------------------------------------------------------------------------------------------------
			- 레코드 작성자 이름을 나타내기 위해 join필요.
			
	- 화면 작성 : view.jsp (write.jsp기반으로 수정)
		> 수정/삭제 버튼 : 게시물 작성자에게만 보이도록
>> lec 17 종료.
>> lec 18

  3> 첨부파일 목록
  	- 화면에서 첨부파일 경로 링크 문자열 생성 : common.js에 공통 메소드 작성되어 있음.
  	- 첨부파일 표시, 다운로드, 삭제
  	- view.jsp
  		> function 추가 : 비동기 방식으로 해당 게시물의 첨부파일 정보를 요청하여 보여줌
  		> RESTful한 url로 요청 : http://localhost/spring02/board/getAttach/5 --> @PathVariable
  		> 파일목록은 list(json배열)로 넘어옴
  		=====================================================================================================
		//첨부파일 리스트를 출력하는 함수
		function listAttach() {
			$.ajax({
				type: "post",
				url: "${path}/board/getAttach/${dto.bno}", // url로 게시물 번호를 전달
				success: function(list){
					//list : json 
					// $(선택자) : 선택자에는 태그/객체가 들어갈 수 있음.
					//  - $("p") : 현재문서의 모든 p태그들
					//	- $("#result") : id가 result인 태그 
					//	- $(".info") : class가 info인 태그
					//	- $(document) : document객체 ==> $(list) : list객체
					// each(function(){}) : 반복문. 각각의 요소마다 function을 실행
					$(list).each(function(){
						// 첨부파일의 정보
						var fileInfo = getFileInfo(this);
						// this : 현재의 객체
						var html = "<div><a href='" + fileInfo.getLink + "'>" + fileInfo.fileName + "</a>&nbsp;&nbsp;";
						html += "<a href='#' class='file_del' data-src='"+ this +"'>[삭제]</a></div>";
						// id가 uploadedList인 태그의 마지막에 추가
						$("#uploadedList").append(html);
					});
				}
			})
		}
  		=====================================================================================================
  		> json의 success
  			- responseText : 응답 텍스트
  			- responseXML : XML로 리턴 (json데이터) --> 대응하는 컨트롤러에서는 @ResponseBody 사용
			- @ResponseBody : view가 아닌 데이터 자체를 리턴, 화면에서는 Array로 받는다.

	- Controller : getAttach/{bno} 작성
		=====================================================================================================
		//첨부파일 목록을 리턴
		// ArrayList를 json배열로 변환하여 리턴
		@RequestMapping("getAttach/{bno}")
		@ResponseBody // view가 아닌 데이터 자체를 리턴
		public List<String> getAttach(@PathVariable int bno) { // url로 전달된 값을 @PathVariable로 받음
			return boardService.getAttach(bno);
		}
		=====================================================================================================
		> url로 전달된 값을 @PathVariable로 받음 : @PathVariable int bno
		> @ResponseBody : view가 아닌 데이터 자체를 리턴
			- 화면으로 List를 넘기는 경우, javascript에는 List자료형이 없고 String배열이 넘어간다.
			- json으로 변환하는 과정은 화면의 common.js의 함수로 수행.
		
	- service, DAO, mapper : bno를 전달받아 쿼리를 실행, 첨부파일 목록을 리턴
		-----------------------------------------------------------------------------------------------------
		<!-- 첨부파일 목록 -->
		<!-- parameterType : 전달 매개값 타입. 생략가능 -->
		<!-- 결과값 필드는 하나, 문자열 타입 : String의 List값이 반환 (필드가 여러개인 경우, dto타입으로 리턴)-->
		<select id="getAttach" parameterType="int" resultType="String">
			select fullName from attach where bno=#{bno} order by regdate desc
		</select>
		-----------------------------------------------------------------------------------------------------

	- 파일 다운로드 : AjaxUploadController의 displayFile() - 스트림으로 처리

	- 파일 삭제 : 화면에 script추가
		====================================================================================================
			
		====================================================================================================
  
 4) 댓글 목록, 쓰기
  
 5) 게시물 수정, 삭제
  
 6) 게시물 검색



























	
