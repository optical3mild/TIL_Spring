lec 16 ~

14. 게시판
 1) 게시판의 주요기능
 	- 로그인 후 게시물 등록, 수정이 가능하도록 처리 (로그인 한 사용자만 등록, 수정가능)
 	- 글쓰기(스마트에디터 적용, 태그문자 처리, 공백처리, 줄바꿈 처리)
 	- 게시물 상세정보, 조회수 증가 처리
 	- 게시물 수정/ 삭제(delete방식, update방식)
 	- 검색기능
 	- 페이지 나누기
 	
 2) 파일 업로드(ajax)
 	- 게시판에 파일 첨부
 	- 첨부파일 목록, 다운로드, 삭제
 	- 수정화면에서 새로운 파일 올리기
 	
 3) 댓글기능
 	- 일반적인 방식으로 댓글쓰기(RestController, REST방식)
 		> $.ajax()함수 호출하여 insert
 		> 컨트롤러에서 뷰로 포워딩한 responseText를 html 태그에 출력
 	- 컨트롤러에서 ArrayList를 json형식으로 리턴받아 댓글 목록 출력(list_json.do)
 	- 목록에 댓글 갯수 표시
 	- 댓글 페이지 나누기(댓글 목록은 일반적인 방식으로 처리)
 	- 비밀댓글 쓰기, 표시
 	- REST방식으로 댓글 쓰기(insert_rest.do)
 		> 크롬 확장프로그램을 이용한 입력처리
 		> {"replytext":"댓글", "replyer":"kim", "bno":"1", "secret_reply":"n"}
 	- REST방식으로 댓글 목록 출력
 	- REST방식으로 댓글 상세확인, 수정, 삭제 기능 구현
 
 4) 구조개요
  1> 테이블
  	- member : 회원 정보
  	- board : 게시물 정보
  	- reply : 댓글 정보
  	- attach : 첨부파일 정보

 5) 글 목록 보기 구현
  1> 게시판 테이블
  	ORACLE ======================================================================================================
		-- cascade constrains 제약조건까지 모두 삭제
		drop table board cascade constrains;
		
		create table board (
			bno number not null,			--게시물 번호
			title varchar2(200) not null,	--제목
			content clob,					--내용
			writer varchar2(50) not null,	--이름
			regdate date default sysdate,	--날짜
			viewcnt number default 0,		--조회수
			primary key(bno)
		);
		
		-- nvl(A,B) A가 null이면 B, null이 아니면 A
		delete from board;
  	=============================================================================================================
  	
  	MYSQL ======================================================================================================
		/* cascade constrains 제약조건까지 모두 삭제*/
		drop table board cascade constrains;
		
		create table board (
			bno int not null auto_increment,	/*게시물 번호*/
			title varchar(200) not null,		/*제목*/
			content text,						/*내용*/
			writer varchar(50) not null,		/*이름*/
			regdate datetime default now(),		/*날짜*/
			viewcnt int default 0,				/*조회수*/
			primary key(bno)
		);
		
		-- nvl(A,B) A가 null이면 B, null이 아니면 A
		delete from board;
		insert into board (bno, title, content, writer) values(1,'제목','내용','kim');
		select * from board;
  	=============================================================================================================

  2> menu에 추가 : <a href="${path}/board/list.do">게시판</a>
  3> com.example.spring02.model.board.dto : BoardDTO.java
  	------------------------------------------------------------------------------------------------------------
		public class BoardDTO {
			// board테이블과 동일한 부분
			private int bno;
			private String title;
			private String content;
			private String writer;		//작성자 id
			private Date regdate;		//java.util.Date
			private int viewcnt;		//조회수
			
			// 테이블에 없는 필드 : join하여 가져올 값
			private String name;		//작성자 이름
			private int cnt;			//댓글 갯수
			private String show;		//화면 표시 여부
			// 첨부파일 테이블을 따로 작성
			private String[] files;		//첨부파일 이름배열
			
			... getter/setter/toString
		}
  	------------------------------------------------------------------------------------------------------------

  4> 댓글, 첨부파일 테이블
  	- 댓글 테이블
  	ORACLE ======================================================================================================
		create table reply (
			rno number not null primary key,	--댓글 번호
			bno number default 0,				--글 번호
			replytext varchar2(1000) not null,	--댓글 내용
			replyer varchar2(50) not null,		--댓글 작성자
			regdate date default sysdate,		--댓글 등록시간
			updatedate date default sysdate		--댓글 수정시간
		);
		
		-- bno 필드에 foreign key 설정
		alter table reply add constraint fk_board foreign key(bno) references board(bno);
		
		-- 시퀀스 생성
		create sequence reply_seq start with 1 increment by 1;
		
		insert into reply(rno,bno,replytext,replyer) values(reply_seq.nextval, 1, '댓글...', 'kim');
  	=============================================================================================================
  	MYSQL ======================================================================================================
		create table reply (
			rno int not null primary key auto_increment, /*댓글 번호 ORACLE의 시퀀스 = AUTO_INCREMENT */
			bno int default 0,					/*글 번호*/
			replytext varchar(1000) not null,	/*댓글 내용*/
			replyer varchar(50) not null,		/*댓글 작성자*/
			regdate datetime default now(),		/*댓글 작성시간*/
			updatedate datetime default now()	/*댓글 수정시간*/
		);
		
		/* bno 필드에 foreign key 설정 : add constraint 제약조건이름 foreign key(필드명) references 테이블(필드)*/
		alter table reply add constraint fk_board foreign key(bno) references board(bno);
		
		/*서브쿼리 : select ifnull(max(rno)+1,1) from reply a */
		insert into reply(rno,bno,replytext,replyer) 
			values((select ifnull(max(rno)+1,1) from reply a), 1, '댓글...', 'kim');
  	=============================================================================================================

  	- 첨부파일 테이블
  	ORACLE ======================================================================================================
		create table attach(
			fullName varchar2(150) not null, 	--첨부파일 이름
			bno number not null,				--board 테이블의 글번호
			regdate date default sysdate,
			primary key(fullName)				--파일 이름에 uuid가 붙어 있어 중복x
		);
		
		--foreign key설정
		alter table attach add constraint fk_board_attach foreign key(bno) references board(bno);
  	=============================================================================================================
  	MYSQL ======================================================================================================
		create table attach(
			fullName varchar(150) not null,		/*첨부파일 이름*/
			bno int not null,					/*board테이블의 글번호*/
			regdate datetime default now(),
			primary key(fullName)				/*파일 이름에 uuid가 붙어 있어 중복x*/
		);
		
		/*foreign key설정*/
		alter table attach add constraint fk_board_attach foreign key(bno) references board(bno);
  	=============================================================================================================

  5> com.example.spring02.model.board.dto : ReplyDTO.java
  6> com.example.spring02.model.board.dao : BoardDAO.java, BoardDAOImpl.java
  	- 게시물 목록 리턴 : listAll()
		> selectList("namespace.id") : 레코드가 2개 이상
		> selectOne() : 레코드가 1개

  7> boardMapper.xml작성
  8> com.example.spring02.service.board : BoardService.java, BoardServiceImpl.java
  9> com.example.spring02.controller.board : BoardController.java
  	- BoardController ==> BoardService ==> BoardDAO ==> boardMapper.xml
  	- HashMap<>() : 여러 데이터를 한번에 묶어 전송가능

  10> views/board/list.jsp작성
  	- map으로 넘어온 내용 {"count"=val, "list"=val{...} }
  	
  11> 목록 화면에서 id대신 이름 출력
>>	- boardMapper.xml의 listAll query 수정
	 -----------------------------------------------------------------------------------------------------------
	 select bno, title, writer, name, regdate, viewcnt 
	 	from board b, member m 		/*테이블 join*/ 
	 	where b.writer=m.userid 	/*게시판 테이블의 writer와 멤버 테이블의 userid가 일치하는것*/
	 	order by bno desc;
	 -----------------------------------------------------------------------------------------------------------

 6) 글쓰기 기능
 	- 회원제 게시판 : 로그인한 사용자에게만 기능을 열어줌
 	- list.jsp 수정 : button을 눌러 글쓰기 화면으로 이동
  1> controller : write()
  2> views/board/write.jsp
  3> 로그인 체크기능 : 회원제 기능을 위한 로그인 체크
  	- sol 1. 화면에서 버튼을 숨김
  		> 세션변수를 확인하여 버튼을 보여주거나 숨김 <c:if test="${sessionScope.userid != null}">
  		> 주소를 직접 입력하면 화면으로 이동가능
  			- 컨트롤러에서도 세션값을 받아 처리하여야 함
				-----------------------------------------------------------------------------------------------
					// sol1. 세션체크하여 로그인여부에 따라 분기
					@RequestMapping("write.do")
					public String write(HttpSession session) {
						if(session.getAttribute("userid") == null) {
							return "member/login";
						}
						// 글쓰기 폼 페이지로 이동
								return "board/write";
					}
				-----------------------------------------------------------------------------------------------
		> --> 화면과 컨트롤러에서 두번 확인하여야 함.
	
	- sol 2. 인터셉터 사용
		> 요청이 들어왔을 때 인터셉터에서 확인 후 컨트롤러로 넘김
			- /board/write.do --> LoginInterceptor(preHandle()) --> BoardController
			
		> servlet-context.xml에 정의한 loginInterceptor를 사용 (코드는 기 작성한 interceptor패키지 참조)
			===================================================================================================
			<!-- 인터셉터 빈을 등록 : class에 전체경로 작성, id는 이 bean을 참조할 변수명 --> 
			<beans:bean id="loginInterceptor" class="com.example.spring02.interceptor.LoginInterceptor"></beans:bean>
			
			<!-- 인터셉터 호출을 위한 url mapping -->
			<!-- beans:ref bean="참조할 bean의 id" -->
			<interceptor>
				<mapping path="/board/write.do" />
				<mapping path="/board/insert.do" />
				<mapping path="/board/update.do" />
				<mapping path="/board/delete.do" />
			</interceptor>
			===================================================================================================

		> interceptor.LoginInterceptor
			===================================================================================================
			// HandlerInterceptorAdapter 추상클래스 상속
			// preHandle(), postHandle() 오버라이딩
			public class LoginInterceptor extends HandlerInterceptorAdapter{
				
				// 메인액션이 실행되기 전
				@Override
				public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
						throws Exception {
					// 세션 객체 생성
					HttpSession session = request.getSession();
					// 세션이 없으면 = 로그인 되지 않은 상태
					if(session.getAttribute("userid") == null) {
						// 로그인 페이지로 이동
						response.sendRedirect(request.getContextPath() + "/member/login.do?message=nologin");
						// 메인 액션으로 돌아가지 않음.
						return false; 
					} else {
						// 메인액션으로 이동
						return true;
					}
				}
			}
			===================================================================================================

  4> controller : insert()
  	===========================================================================================================
		// write.jsp에서 입력한 내용들이 BoardDTO에 저장됨
		@RequestMapping("insert.do")
		// @ModelAttribute 생략가능
		public String insert(@ModelAttribute BoardDTO dto, HttpSession session) throws Exception{
			// 세션에서 사용자 아이디를 가져옴 
			//		: 화면에서 넘겨주는 폼 데이터에는 아이디가 없음. 저장을 위해서 세션에서 받아야 한다.
			String writer = (String)session.getAttribute("userid");
			dto.setWriter(writer);
			// 레코드 저장
			boardService.create(dto);
			// 게시물 목록으로 이동
			return "redirect:/board/list.do";
		}
  	===========================================================================================================
  
  5> service, model(dao) : create() --> create()
  6> mapper
  	===========================================================================================================
  		<insert id="insert">
			insert into board(bno,title,content,writer)
				values((select ifnull(max(bno)+1,1) from board a), #{title}, #{content}, #{writer})
		</insert>
  	===========================================================================================================

 7) 글쓰기 페이지 파일첨부 기능 - drag&drop
  1> write.jsp : script 추가
	===========================================================================================================
		<!-- 페이지에서 사용할 javascript 메서드 -->
		<script src="${path }/include/js/common.js"></script>
		
		<script type="text/javascript">
		$(function(){
			$("#btnSave").click(function(){
				var str = "";
				// uploadedList 내부의 .file 태그를 각각 반복
				$("#uploadedList .file").each(function(i) { // i=index 해당하는 태그 목록의 순서대로 index 생성
					//hidden 태그 수정하여 추가. 
					//$(this) = 현재 작업중인 태그
					str += "<input type='hidden' name='files["+i+"]' value='" + $(this).val() +"'>";	
				});
				// 폼에 hidden 태그들을 붙여 폼의 정보(제목, 내용)와 같이 hidden 태그를 전송
				$("#form1").append(str);
				document.form1.submit();
			});
			
			$(".fileDrop").on("dragenter dragover", function(e){
				//기본효과 막음 : drop의 기본효과 = 해당 파일을 브라우저에서 보여줌
				e.preventDefault();
			});
		
			$(".fileDrop").on("drop", function(e){
				//기본효과 막음
				e.preventDefault();
				//첫번째 첨부파일 : 다중업로드 불가
				var files = e.originalEvent.dataTransfer.files;
				var file = files[0];
				//폼 데이터에 첨부파일 추가
				var formData = new FormData();
				formData.append("file", file);
				$.ajax({
					url: "${path}/upload/uploadAjax",
					data: formData,
					dataType: "text", // 웹에서 정보를 넘기므로 text형태로 넘김
					processData: false,	// 진행률 옵션
					contentType: false,
					type: "post",
					success: function(data) {
						console.log(data);
						//data : 업로드한 파일 정보, http상태코드
						var fileInfo = getFileInfo(data);
						console.log(fileInfo);
						var html = "<a href='" +fileInfo.getLink+"'>" + fileInfo.fileName+"</a><br>";
						
						// hidden tag생성
						html += "<input type = 'hidden' class='file' value='" + fileInfo.fullName+ "'>";
						$("#uploadedList").append(html);
					}
				});
			});
		});
		</script>
	===========================================================================================================
		> AjaxUploadController에서 처리. (이전 예제에서 구현한 코드 사용. )
		> 사용할 메서드를 따로 file로 만들어 사용

>> **lec 16 1:28:55 파일첨부 기능구현 설명	
		> 확인 버튼을 눌렀을 때, 첨부된 파일의 정보는 첨부파일 테이블에 저장되도록 기능 구현
		> 전송버튼을 눌렀을 때, drop시 만들어진 hidden tag를 찾아 form 태그에 내용을 바꾸어 추가.
		> boardController로 데이터가 넘어가 files필드에 hidden tag의 name(files[0]등)에 따라 value가 배열로 저장됨

  2> BoardServiceImpl : create()
  	- 컨트롤러에서 받은 dto정보를 각각의 테이블에 저장
  	- board table에 레코드 추가 : boardDao.create(dto)
  	- attach table에 첨부파일 레코드 추가 : boardDao.addAttach(dto);
  	===========================================================================================================
		// 하나의 메서드에 두가지 동작 --> 트랜젝션 처리 필요
		//1. 글쓰기 - 게시물 번호 생성
		//2. 첨부파일 등록 - 게시물 번호 사용
		@Transactional
		@Override
		public void create(BoardDTO dto) throws Exception {
			//board 테이블에 레코드 추가
			boardDao.create(dto);
			
			//attach 테이블에 레코드 추가
			String[] files = dto.getFiles();
			if(files == null) return; //첨부파일이 없으면 skip
			for(String name : files) {
				boardDao.addAttach(name); // attach 테이블에 insert
			}
		}
  	===========================================================================================================
  		> 하나의 서비스에 두가지 동작이 발생 --> 트랜잭션 처리 필요.

  3> BoardDAOImpl : addAttach()
  4> boardMapper
  	===========================================================================================================
	<insert id="addAttach">
		insert into attach(fullName, bno) values (#{fullName}, (select ifnull(max(bno),1) from board a))
	</insert>
  	===========================================================================================================
	- select ifnull(max(bno)) from board a 
		: service에서 board테이블에 레코드를 추가 후 attach테이블에 레코드를 추가 하므로,
	 	현재 작업중인 레코드 번호는 제일 마지막 번호가 된다.

>> lec 16 종료.
>> lec 17

  5> 글쓰기 페이지 스마트 에디터 적용 : write.jsp
  	===========================================================================================================
	<!-- CKEditor -->
	<script src="${path }/ckeditor/ckeditor.js"></script>
	
	<script>
		$(function(){
			//CKEDTOR적용
			CKEDITOR.replace("content", {
				//파일업로드를 처리할 주소
				filebrowserUploadUrl: "${path}/imageUpload.do"
			});
		});
	</script>
  	===========================================================================================================

 2) 페이지 나누기
  1> 페이지 / 페이지 블록 계산
 	- 페이지당 게시물 수 : 10개
 	- 전체 게시물 수 : 991개
 	- 페이지 계산 : 991/10 = 99.1올림 ==> 100
 	
 	- 페이지의 시작번호, 끝번호 계산
 		> where rn between 1 and 10
 		> 1페이지 = 1~10 / 2페이지 = 11~20 ... 99페이지 = 981~990
 	
 	- 시작번호 = (현재페이지 - 1) * 페이지 당 게시물 수 + 1 
 		> 2페이지 = (2-1) * 10 + 1 ==> 11
 		> 7페이지 = (7-1) * 10 + 1 ==> 61
 	
 	- 끝번호 = 시작번호 + 페이지당 게시물 수 - 1
 		> 1페이지 = 1 + 10 - 1 ==> 10
 		> 2페이지 = 11 + 10 - 1 ==> 20
 		
 	- 전체 페이지 블록 수 = 전체 페이지 갯수 / 10
 		> 91/10 ==> 9.1 => 10개
 		
 	- 현재 페이지가 속한 블록 = (현재 페이지 - 1) / 페이지 블록단위 + 1
 		> 1페이지 ==> (1-1)/10 + 1 --> 1 
 		> 9페이지 ==> (9-1)/10 + 1 --> 1
 		> 57페이지 ==> (57-1)/10 + 1 --> 6
 	
 	- 페이지 블록의 시작번호 = (현재블록 - 1) * 블록단위 + 1
 		> 1블록 ==> (1-1)*10 + 1 ==> 1
 		> 2블록 ==> (2-1)*10 + 1 ==> 11
 		
 	- 페이지 블록의 끝번호 = 블록 시작번호 + 블록단위 - 1
		> 1블록 ==> 1 + 10 - 1 ==> 10
		> 2블록 ==> 11 + 10 - 1 ==> 20
		> 6블록 ==> 51 + 10 - 1 ==> 60

	- 페이지 표시
		=======================================================================================================
		ex) 11페이지
		
		> 화면 : [이전] 11 12 13 ... 20 [다음]
		
		> 몇번째 블록인지 계산
			- (현재페이지 -1 ) / 페이지 블록단위 +1 : (11 - 1) / 10 + 1 = 2번째 블록 (몇페이지 ~ 몇페이지)
		> 해당 블록의 첫번째 페이지 계산
			- (현재블록 - 1) * 블록단위 + 1 : (2-1)*10 + 1 = 11페이지
		=======================================================================================================

  2> 테이블 정리
  	- 게시물 1000개 입력
  		OARCLE ================================================================================================
			declare
				i number := 1;
			begin
				while 1<=1000 loop
					insert into board (bno, title, content, writer) 
						values((select nvl(max(bno)+1,1) from board), '제목'||i, '내용'||i, 'kim');
					i := i+1;
				end loop;
			end;
			/
			select count(*) from board;
			select * from board;
  		=======================================================================================================
  		MYSQL =================================================================================================
  		**ALTER TABLE `attach` DROP FOREIGN KEY `fk_board_attach`;
  		
  		**plsql
			delimiter $$
	
			DROP PROCEDURE IF EXISTS spring.datatest$$
			
			CREATE PROCEDURE spring.datatest(idx INT)
			
			BEGIN
				DECLARE i INT DEFAULT 1;
				while i<=idx do
					insert into board (bno, title, content, writer) 
						values((select ifnull(max(bno)+1,1) from board a), (concat('제목',i)), (concat('내용',i)), 'kim');
					set i = i+1;
				END while;
			END $$;
			
			delimiter;
			
			CALL spring.datatest(997);
  		=======================================================================================================

>>	- select query 수정
		> 전체 레코드를 조회하고, 결과를 임시테이블에 넣고 레코드에 일련번호를 매긴 후 필요한 부분을 출력.
		ORACLE ================================================================================================
			-- rownum : 출력순서
			select *
			from (
				/*해당 select로 출력되는 모든 레코드를 A라는 테이블로 정의 + rownum(일련번호)*/
				select rownum as rn, A.*
				from (
					/* 전체 레코드를 불러오는 query */
					select bno, title, writer, name, regdate, viewcnt 
				 	from board b, member m
				 	where b.writer=m.userid
				 	order by bno desc
			 	) A
			) where rn between 1 and 10;
		=======================================================================================================

		MYSQL ================================================================================================
		** MYSQL의 모든 서브쿼리는 alias가 필요하다. EX) select * from board b... --> b 가 alias
			SELECT R.*
			from (
				/*해당 select로 출력되는 모든 레코드를 A라는 테이블로 정의 + @rownum(일련번호 변수)*/
				SELECT @rownum:=@rownum+1 AS rn, A.*
				from (
					/* 전체 레코드를 불러오는 query */
					select bno, title, writer, name, regdate, viewcnt 
				 	from board b, member m
				 	where b.writer=m.userid
				 	order by bno desc
			 	) A, /* 검색된 내용 --> 임시테이블의 형태를 가짐. alias로 테이블의 이름을 부여 */
			 	(SELECT @rownum:=0) N /* 서브쿼리로 변수 초기화 */
			) R WHERE R.rn BETWEEN #{start} AND #{end}
		=======================================================================================================

  3> 페이저 클래스 작성
  	- service.board : Pager.java
  		> 각 변수, 페이지/블록의 계산 메소드 작성
  
  4> controller 수정 : list.do
  	=========================================================================================================
		@RequestMapping("list.do")	// 세부적인 url pattern
		public ModelAndView list(@RequestParam(defaultValue="1") int curPage) throws Exception {
			//레코드 갯수 계산
			int count = boardService.countArticle();
			//페이지 관련 설정
			Pager pager = new Pager(count, curPage);
			int start =  pager.getPageBegin();
			int end = pager.getPageEnd();
			
			List<BoardDTO> list = boardService.listAll(start, end);	// 게시물 목록
			ModelAndView mav = new ModelAndView();
			HashMap<String, Object> map = new HashMap<>();
			
			map.put("list", list);		// map에 자료 저장
			map.put("count", count);	// 게시물 총 갯수
			
			map.put("pager", pager);	// 페이지 네비게이션을 위한 변수
			
			mav.setViewName("board/list"); // 포워딩할 view의 이름
			mav.addObject("map", map);	//ModelAndView에 map을 저장
			
			return mav; // board/list.jsp로 이동
		}
  	=========================================================================================================
	- 레코드 총 갯수 필요		
		> service, model(dao) 작성 : countArticle(), return 값 int
		> mapper 작성
			==================================================================================================
			  	<select id = "countArticle" resultType="int">
					select count(*) from board
				</select>
			==================================================================================================
	- 요청에 따라 페이지가 바뀌어야 하므로, 매개변수값을 받도록 추가한다.
	
	- boardService와 boardDao의 listAll을 매개변수(start, end)가 들어간 메소드로 수정
		> 인터페이스와 메소드 모두 매개변수를 받아 전달하도록 수정
		> DAOImpl에서는 sqlSession의 함수인 selectList()가 여러개의 매개변수를 전달 할 수 없음
			--> dto나 map으로 묶어 전달.
			==================================================================================================
				// 게시물 목록 리턴
				@Override
				public List<BoardDTO> listAll(int start, int end) throws Exception {
					// Map<key의 자료형, value의 자료형>
					Map<String, Object> map = new HashMap<>();
					map.put("start", start);
					map.put("end", end);
					// mapper에는 2개 이상의 값을 전달 할 수 없음(dto또는 map사용)
					return sqlSession.selectList("board.listAll", map);
				}
			==================================================================================================
		> mapper에 map으로 값이 전달 : 속성에 parameterMap설정으로 받을 수 있고, 생략가능하다.

	- 매개값을 넣어 작동 test : http://localhost:8080/spring02/board/list.do?curPage=10
	
  5> 화면 하단에 페이지 번호 추가 : views/board/list.jsp
  	=========================================================================================================
		<!-- 페이지 네비게이션 출력 -->
		<tr>
			<td colspan = "5" align="center">
				<!-- [처음] : 첫번째 블록인 경우 표시되지 않음-->
				<c:if test="${map.pager.curPage > 1 }">
					<a href="#" onclick="list('1')">[처음]</a>
				</c:if>
	
				<!-- [이전] : 첫번째 블록인 경우 표시되지 않음-->
				<c:if test="${map.pager.curBlock > 1 }">
					<a href="#" onclick="list('${map.pager.prevPage}')">[이전]</a>
				</c:if>
				
				<!-- forEach var="개별데이터" begin="시작" end="끝" : 횟수가 고정적-->
				<c:forEach var="num" begin="${map.pager.blockBegin }" end="${map.pager.blockEnd }">
					<c:choose>
						<c:when test="${num == map.pager.curPage }">
							<!-- 현재 페이지인 경우 숫자만 출력하고 색을 넣어 현재페이지 표시 -->
							<span style="color:red;">${num }</span>
						</c:when>
						<c:otherwise>
							<a href="#" onclick="list('${num}')">${num }</a>
						</c:otherwise>
					</c:choose>
				</c:forEach>
				
				<!-- [다음] : 마지막 블록인 경우 표시되지 않음-->
				<c:if test="${map.pager.curBlock < map.pager.totBlock}">
					<a href="#" onclick="list('${map.pager.nextPage}')">[다음]</a>
				</c:if>
	
				<!-- [끝] : 마지막 블록인 경우 표시되지 않음-->
				<c:if test="${map.pager.curPage < map.pager.totPage}">
					<a href="#" onclick="list('${map.pager.totPage}')">[끝]</a>
				</c:if>
			</td>
		</tr>
		...
		<script>
			...
			function list(page){
				location.href = "${path}/board/list.do?curPage="+page;
			}
		</script>
  	=========================================================================================================
	- forEach 용법
		> c:forEach var="개별데이터" begin="시작" end="끝" : 횟수가 고정적
		> c:foreach var="개별데이터" items="집합데이터" : 횟수가 가변적
	- hyper link로 연결되지 않고 이벤트 실행 : java script function 추가

>>lec 17 1:14:00 ~

 3) 상세페이지
 	- 상세페이지 화면을 보면 조회수 증가
 	
  1> list.jsp : 목록의 각 항목의 제목을 하이퍼링크로 처리
  2> controller : view.do
  	=========================================================================================================
		@RequestMapping("view.do")
		public ModelAndView view(int bno, HttpSession session) throws Exception{
			// 조회수 증가 처리
			boardService.increaseViewcnt(bno, session);
			ModelAndView mav = new ModelAndView();
			mav.setViewName("board/view");	//포워딩할 뷰의 이름
			mav.addObject("dto", boardService.read(bno));	// 해당 게시물을 가져와 자료 저장
			return mav; // views/board/view.jsp로 넘어가서 출력됨
		}  
  	=========================================================================================================
	- session 값을 service로 전달 : 일정 시간안에 조회된 수 만큼만 증가하도록 처리
	
	- 조회수 증가 처리
		> service : increaseViewcnt(int bno, HttpSession session)
			- 연속으로 조회수 증가되지 않도록 시간제한 설정 : 5초에 한번 조회수 증가되도록 작성.
			------------------------------------------------------------------------------------------------
				//조회수 증가 처리
				// session을 이용하여 조회수 증가 제한
				@Override
				public void increaseViewcnt(int bno, HttpSession session) throws Exception {
					long update_time = 0;
					if(session.getAttribute("update_time_"+bno) != null) {
						// 최근에 조회수를 올린 시간
						update_time = (long)session.getAttribute("update_time_"+bno);
					}
					long current_time = System.currentTimeMillis();
					// 일정시간이 경과한 후 조회수 증가처리
					if(current_time - update_time > 5*1000)	{
						// 조회수 증가 처리
						boardDao.increateViewcnt(bno);
						// 조회수를 올린 시간 저장
						session.setAttribute("update_time_"+bno, current_time);
					}
				}
			-------------------------------------------------------------------------------------------------
  		> dao : increaseViewcnt(int bno)
  		> mapper
  			-------------------------------------------------------------------------------------------------
			<update id="increaseViewcnt">
				update board set viewcnt = viewcnt+1 where bno=#{bno}
			</update>
  			-------------------------------------------------------------------------------------------------
	
	- 게시물 번호를 매개값으로 해당 게시물 가져오기 : boardService.read(bno)
  		> service : read(bno)
  		> dao : read(bno)
  		> mapper : select id="read"
  			-------------------------------------------------------------------------------------------------
			<select id="read" resultType="com.example.spring02.model.board.dto.BoardDTO">
				select bno, title, regdate, content, viewcnt, name, writer
					 from board b, member m
					 where b.writer=m.userid and bno=#{bno}
			</select>
  			-------------------------------------------------------------------------------------------------
			- 레코드 작성자 이름을 나타내기 위해 join필요.
			
	- 화면 작성 : view.jsp (write.jsp기반으로 수정)
		> 수정/삭제 버튼 : 게시물 작성자에게만 보이도록
>> lec 17 종료.
>> lec 18

  3> 첨부파일 목록
  	- 화면에서 첨부파일 경로 링크 문자열 생성 : common.js에 공통 메소드 작성되어 있음.
  	- 첨부파일 표시, 다운로드, 삭제
  	- view.jsp
  		> function 추가 : 비동기 방식으로 해당 게시물의 첨부파일 정보를 요청하여 보여줌
  		> RESTful한 url로 요청 : http://localhost/spring02/board/getAttach/5 --> @PathVariable
  		> 파일목록은 list(json배열)로 넘어옴
  		=====================================================================================================
		$(function(){
			listAttach();
		})
		
		//첨부파일 리스트를 출력하는 함수
		function listAttach() {
			$.ajax({
				type: "post",
				url: "${path}/board/getAttach/${dto.bno}", // url로 게시물 번호를 전달
				success: function(list){
					//list : json 
					// $(선택자) : 선택자에는 태그/객체가 들어갈 수 있음.
					//  - $("p") : 현재문서의 모든 p태그들
					//	- $("#result") : id가 result인 태그 
					//	- $(".info") : class가 info인 태그
					//	- $(document) : document객체 ==> $(list) : list객체
					// each(function(){}) : 반복문. 각각의 요소마다 function을 실행
					$(list).each(function(){
						// 첨부파일의 정보
						var fileInfo = getFileInfo(this);
						// this : 현재의 객체
						var html = "<div><a href='" + fileInfo.getLink + "'>" + fileInfo.fileName + "</a>&nbsp;&nbsp;";
						html += "<a href='#' class='file_del' data-src='"+ this +"'>[삭제]</a></div>";
						// id가 uploadedList인 태그의 마지막에 추가
						$("#uploadedList").append(html);
					});
				}
			})
		}
  		=====================================================================================================
  		> json의 success
  			- responseText : 응답 텍스트
  			- responseXML : XML로 리턴 (json데이터) --> 대응하는 컨트롤러에서는 @ResponseBody 사용
			- @ResponseBody : view가 아닌 데이터 자체를 리턴, 화면에서는 Array로 받는다.

	- Controller : getAttach/{bno} 작성
		=====================================================================================================
		//첨부파일 목록을 리턴
		// ArrayList를 json배열로 변환하여 리턴
		@RequestMapping("getAttach/{bno}")
		@ResponseBody // view가 아닌 데이터 자체를 리턴
		public List<String> getAttach(@PathVariable int bno) { // url로 전달된 값을 @PathVariable로 받음
			return boardService.getAttach(bno);
		}
		=====================================================================================================
		> url로 전달된 값을 @PathVariable로 받음 : @PathVariable int bno
		> @ResponseBody : view가 아닌 데이터 자체를 리턴
			- 화면으로 List를 넘기는 경우, javascript에는 List자료형이 없고 String배열이 넘어간다.
			- json으로 변환하는 과정은 화면의 common.js의 함수로 수행.
		
	- service, DAO, mapper : bno를 전달받아 쿼리를 실행, 첨부파일 목록을 리턴
		-----------------------------------------------------------------------------------------------------
		<!-- 첨부파일 목록 -->
		<!-- parameterType : 전달 매개값 타입. 생략가능 -->
		<!-- 결과값 필드는 하나, 문자열 타입 : String의 List값이 반환 (필드가 여러개인 경우, dto타입으로 리턴)-->
		<select id="getAttach" parameterType="int" resultType="String">
			select fullName from attach where bno=#{bno} order by regdate desc
		</select>
		-----------------------------------------------------------------------------------------------------

	- 파일 다운로드 : AjaxUploadController의 displayFile() - 스트림으로 처리

	- 파일 삭제 : 화면에 script추가
		====================================================================================================
			//첨부파일 삭제
			// id가 uploadedList인 태그의 class가 file_del인 태그 클릭
			$("#uploadedList").on("click", ".file_del", function(e){
				var that = $(this); //클릭한 태그
				$.ajax({
					type : "post",
					url : "${path}/upload/deleteFile",
					data : {fileName : $(this).attr("data-src")},
					// data : "fileName="+$(this).attr("data-src"),
					dataType : "text",
					success : function(result) {
						if(result == "deleted")	{
							//화면에서 태그 제거
							that.parent("div").remove();
						}
					}
				})
			})
		====================================================================================================
  		> controller : 기존의 AjaxUploadController.java 사용.
  		> 로컬에 저장된 파일은 지워졌으나, db의 레코드는 삭제되지 않음
  		
  	- 파일 레코드 삭제 : 첨부파일 테이블의 레코드 삭제
  		> AjaxUploadController.java : deleteFile수정
  			================================================================================================
			@Inject
			BoardService boardService;
			
			// 이미지파일 --> 썸네일 삭제, 원본이미지 삭제
			// 이미지파일이 아닌경우 --> 원본파일 삭제
			@ResponseBody // 뷰가 아닌 데이터를 리턴
			@RequestMapping(value="/upload/deleteFile", method=RequestMethod.POST)
			public ResponseEntity<String> deleteFile(String fileName){
				logger.info("fileName: " + fileName);
				// 확장자 검사 - 확장자 문자열 추출
				String formatName = fileName.substring(fileName.lastIndexOf(".") + 1); // .다음부터 문자열 절삭
				// static class에서 해당 값을 가져옴 - 해당하는 값이 없는 경우 null이 저장되어 있음.
				MediaType mType = MediaUtils.getMediaType(formatName);
				if(mType != null) { // 이미지 파일이면 원본이미지 삭제
					String front = fileName.substring(0,12);
					String end = fileName.substring(14);
					// File.separatorChar : 유닉스 / 윈도우즈 \
					new File(uploadPath + (front+end).replace('/', File.separatorChar)).delete();
				}
				// 원본파일 삭제(이미지이면 썸네일 삭제), replace("oldchar", "newchar")
				new File(uploadPath + fileName.replace('/', File.separatorChar)).delete();
				
				//레코드 삭제
				boardService.deleteFile(fileName);
				
				return new ResponseEntity<String>("deleted", HttpStatus.OK);
			}
  			================================================================================================
  			- boardService inject, 리턴 전 boardService.delete(fileName) 수행
  		
  		> BoardService : boardDAO.deleteFile(fullName);
  		> BoardDAO : sqlSession.delete("board.deleteFile", fullName);
  		> boardMapper.xml
  			------------------------------------------------------------------------------------------------
			<!-- 첨부파일 레코드 삭제 -->
			<delete id="deleteFile">
				delete from attach where fullName = #{fullName}
			</delete>
  			------------------------------------------------------------------------------------------------
  		
  		** 에러 메시지 =====================================================================================
  		- Mapped Statements collection does not contain value for board.deleteFile
  			 > board.deleteFile을 찾을 수 없다 = 수정 후 서버를 재시작 하지 않아 등록되지 않은경우.
		====================================================================================================

	- 목록 버튼 : view.jsp의 script 추가 (목록화면을 연결해주는 컨트롤러를 호출)
	- 수정 버튼
		> view.jsp : form안에 첨부파일 정보가 없으므로, 정보를 수집하여 넣어주는 작업 필요.
			================================================================================================
			// 수정버튼
			$("#btnUpdate").click(function() {
			//첨부파일 정보를 폼에 추가
				var str = "";
				// #uploadedList .file : id가 uploadedList인 태그의 자식태그 중에서 class가 .file인 태그
				$("#uploadedList .file").each(function(i){
					str += "<input type='hidden' name='files["+i+"]' value='"+$(this).val()+"'>";
				});
				// 폼에 추가
				$("#form1").append(str);
				// form1의 액션 지정
				document.form1.action="${path}/board/update.do";
				// form1을 전송
				document.form1.submit();
			});
			================================================================================================
			- 추가할 파일의 태그는 str로 구성되나 form1에 append(str)이 수행되어 전송전에 form1에 태그로 추가됨.
				> 순서대로 files[i]형식의 name을 가지고 추가되어 전송 시 dto내 필드의 배열에 쌓임
		
		> BoardController
			================================================================================================
			//게시물 내용 수정
			@RequestMapping("update.do")
			public String update(BoardDTO dto) throws Exception {
				if(dto != null) {
					boardService.update(dto);
				}
				// 수정 완료 후 목록으로 이동
				return "redirect:/board/list.do";
				// 수정 후 해당글 화면으로 이동
				//return "redirect:/board/view.do?bno="+dto.getBno();
			}
			================================================================================================
>>			- 파일이 dto내 해당하는 필드에 배열로 쌓임
				> name='files[i]' : 넘어오는 태그 이름이 필드 배열의 자료 한칸에 맞춰져 있음.

		> service : update() - transaction 처리 @Transactional
			- board table 수정
			- attach table 수정
		> DAO : update(), updateAttach()
			- 게시물 수정 : sqlSession.update("board.update", dto);
			- 첨부파일 수정 : updateAttach() ==> insert가 실행되어야 함.
				> 파일을 추가 = insert
				> 기존에 있던 파일 뒤에 파일 추가 = insert
				> 기존의 파일 삭제 = delete ==> 따로 ajax를 이용하여 delete가 실행됨.
				-------------------------------------------------------------------------------------------
					// 첨부파일 정보 수정
					@Override
					public void updateAttach(String fullName, int bno) {
						Map<String, Object> map = new HashMap<>();
						map.put("fullName", fullName); //첨부파일 이름
						map.put("bno", bno); //게시물 번호
						sqlSession.insert("board.updateAttach", map);
					}
				-------------------------------------------------------------------------------------------
				
		> mapper
			-----------------------------------------------------------------------------------------------
				<!-- 게시물 내용 수정 -->
				<update id="update">
					update board set title=#{title}, content=#{content}, where bno=#{bno}
				</update>
				
				<!-- 새로운 첨부파일 추가 -->
				<insert id="updateAttach">
					insert into attach(fullName, bno) values(#{fullName}, #{bno})
				</insert>
			-----------------------------------------------------------------------------------------------
		
		> 첨부파일 [삭제] 링크 : view.jsp
			- 작성자 본인만 볼 수 있도록 하여야 하므로, 세션의 userid와 글의 writer비교하여 일치하는 경우에만 생성
			-----------------------------------------------------------------------------------------------
				//첨부파일 리스트를 출력하는 함수
				function listAttach() {
					$.ajax({
							...
							$(list).each(function(){
								...
								
								// 접속한 유저와 글 작성자가 일치하는 경우에 화면에 나타냄
								<c:if test ="${sessionScope.userid == dto.writer}">
									html += "<a href='#' class='file_del' data-src='"+ this +"'>[삭제]</a></div>";
								</c:if>
								
								// id가 uploadedList인 태그의 마지막에 추가
								$("#uploadedList").append(html);
							});
						}
					})
				}
			-----------------------------------------------------------------------------------------------
				> javascript안에 jstl을 사용할 수 있으나, 피할 것. (추후 적용 시 매개변수로 해당 세션값을 받아 js로 구현할 것)
	
		
	** 테이블 구성 =========================================================================================
	- '1 : 다' 관계일 때 각 테이블을 따로 생성
		> 게시판 board / 첨부파일 attach / 댓글 reply 로 나누어 구성
			<example>
				- 회원				- 회원주소
				> kim				> 서울
									> 인천
									> 대구
									> 강릉
				
				-고객				- 배송지
				> kim				> 서울
									> 회사
									> 동생
	========================================================================================================
>> lec 18 : 1:07:00 ~
  
 4) 댓글 목록, 쓰기
  1> 코드 구성
  	- controller : com.example.spring02.controller.board - ReplyController.java
  	- service : com.example.spring02.service.board - ReplyService.java, ReplyServiceImpl.java
  	- dao : com.example.spring02.model.dao - ReplyDAO.java, ReplyDAOImpl.java
  	- dto : com.example.spring02.model.dto - ReplyDTO.java
  	- mapper : replyMapper.xml
  
  2> 화면 - 목록표시, 쓰기버튼
  	- view.jsp
  		======================================================================================================
		<!-- 댓글 작성 -->
		<div style="width:700px; text-align: center;">
			<c:if test="${sessionScope.userid != null}">
				<textarea rows="5" cols="60" id="replytext" placeholder="댓글을 작성하세요"></textarea>
				<br>
				<button type="button" id="btnReply">댓글쓰기</button>
			</c:if>
		</div>
		
		<!-- 댓글 목록 -->
		<div id="listReply"></div>
		...
		<script>
		$(function(){
			//댓글 쓰기
			$("#btnReply").click(function(){
				var replytext = $("#replytext").val(); //댓글 내용
				var bno = "${dto.bno}"; //게시물 번호
				var param = {"replytext" : replytext, "bno" : bno};
				// var param = "replytext="+replytext+"&bno="+bno;
				$.ajax({
					type : "post",
					url : "${path}/reply/insert.do",
					data : param,
					success : function(){
						alery("댓글이 등록되었습니다.");
					}
				});
			});
		})
		</script>
  		======================================================================================================
  	
  3> 댓글 쓰기
  	- controller
  		======================================================================================================
		//@ResponseBody를 붙이지 않아도 뷰가 아닌 데이터 리턴가능 = 뷰로 돌아가지 않아도 됨. spring4.0부터 사용가능.
		@RestController
		@RequestMapping("reply/*")
		public class ReplyController {
			
			@Inject
			ReplyService replyService;
		
			@RequestMapping("insert.do") //세부적인 url pattern
			public void insert(ReplyDTO dto, HttpSession session) {
				// 댓글 작성자 id
				String userid = (String)session.getAttribute("userid");
				dto.setReplyer(userid);
				// 댓글이 테이블에 저장됨
				replyService.create(dto);
				// jsp페이지로 가거나 데이터를 리턴하지 않음 
			}
		}
  		======================================================================================================
  		> view에서 작성자 정보를 주지 않고, session의 정보를 받아 저장.
  		> 화면으로 넘어가지 않고 종료.
  		
  	- service, dao : create(dto);
  	- mapper
  		------------------------------------------------------------------------------------------------------
		<insert id="insertReply">
			insert into reply (rno, bno, replytext, replyer)
				values ((select ifnull(max(rno)+1,1) from reply a), #{bno}, #{replytext}, #{replyer})
		</insert>
  		------------------------------------------------------------------------------------------------------

lec 18 종료
lec 19~
  
  4> 댓글 목록 출력
  	- ajax방식으로 목록 갱신
  		> view.jsp --> ReplyController --> reply_list.jsp : responseText(응답텍스트)
  		> view.jsp --> ReplyController : ArrayList형식으로 리턴(Json)
  		
  	- view.jsp
  		------------------------------------------------------------------------------------------------------
		<script>
		$(function(){ // 자동으로 실행되는 코드
		
			listReply(); // 댓글 목록 출력
	
			//댓글 쓰기
			$("#btnReply").click(function(){
				var replytext = $("#replytext").val(); //댓글 내용
				var bno = "${dto.bno}"; //게시물 번호
				var param = {"replytext" : replytext, "bno" : bno};
				// var param = "replytext="+replytext+"&bno="+bno;
				$.ajax({
					type : "post",
					url : "${path}/reply/insert.do",
					data : param,
					success : function(){
						alert("댓글이 등록되었습니다.");
		>>				listReply(); // 댓글 목록 출력
					}
				});
			});
		...
		});
		...
		
		//댓글 목록 출력함수 1 : responseText로 댓글 화면부분 전체 코드를 받아와 현재화면에 삽입
		function listReply() {
			$.ajax({
				type: "get",
				url: "${path}/reply/list.do?bno=${dto.bno}",
				success: function(result){
					$("#listReply").html(result);
					console.log(result);
				}
			})
		}
		
		</script>
  		------------------------------------------------------------------------------------------------------
  		> 처음과 댓글쓰기 다음 listReply() 호출하여 <div id="listReply"></div>에 출력
  		
  	- 1. 응답텍스트 리턴
  		> 데이터와 화면을 구성하여 해당화면의 html코드 전체를 텍스트로 리턴 = jsp로 출력되는 결과 전체를 리턴
  		> jsp를 따로 생성하여야 함 / jsp페이지를 만들어 출력하므로 화면을 구성하기 편리
  		
  		> controller : list.do
  			--------------------------------------------------------------------------------------------------
			@RequestMapping("list.do")
			public ModelAndView list(int bno, ModelAndView mav) {
				List<ReplyDTO> list = replyService.list(bno); //댓글 목록
				mav.setViewName("board/reply_list"); //뷰의 이름
				mav.addObject("list", list); //뷰에 전달될 데이터 저장
				return mav; //뷰로 이동
			}
  			--------------------------------------------------------------------------------------------------
 >> 		- mav에 저장된 뷰를 데이터와 함께 리턴 = 화면을 구성하여 해당화면의 html코드 전체를 텍스트로 리턴한다.
  		
  		> service, DAO : list(int bno);
  		> mapper
  			--------------------------------------------------------------------------------------------------
			<!-- 댓글목록 -->
			<select id="listReply" resultType="com.example.spring02.model.reply.dto.ReplyDTO">
				select rno, bno, replyer, regdate, updatedate, name, replytext
				 from reply r, member m
				 where r.replyer = m.userid and bno=#{bno}
				 order by rno 
			</select>
  			--------------------------------------------------------------------------------------------------
  		
  		> 출력화면 : views/board/reply_list.jsp
  			==================================================================================================
			...
			<body>
			<!-- 2. 줄바꿈 처리 관련 값 설정 : jstl의 안에서는 '\n', '\\n'사용 불가-->
			<% pageContext.setAttribute("newLineChar", "\n"); %>
			<table style="width:700px">
				<c:forEach var="row" items="${list }">
				
					<!-- 3. 태그 문자 처리(무력화) : 2.줄바꿈 처리에서 <br>을 사용하므로, 그 전에 처리. -->
					<c:set var="str" value="${fn:replace(row.replytext, '<','&lt;') }" />
					<c:set var="str" value="${fn:replace(str, '<','&gt;') }" />
			
					<!-- fn사용을 위해 태그라이브러리 fn(jstl/functions)추가 필요 : header.jsp에 추가-->
					<!-- 1. 공백처리 : fn:replace(원본문자열 객체, 찾을문자열 형태, 바꿀 문자열) -->
					<c:set var="str" value="${fn:replace(str,'  ','&nbsp;&nbsp;')}" />
			
					<!-- 2. 줄바꿈 처리 : jstl안에서 '\n'사용불가로 미리 선언한 변수값을 가져옴 -->
					<c:set var="str" value="${fn:replace(str, newLineChar,'<br>')}" />
					<tr>
						<td>
							${row.name }
							(<fmt:formatDate value="${row.regdate }" pattern="yyyy-MM-dd a HH:mm:ss" />)<br>
							${str} <!-- jstl로 변환한 내용을 출력 -->
						</td>
					</tr>
				</c:forEach>
			</table>
			</body>
  			==================================================================================================
  			- 컨트롤러에서 화면을 responseText로 리턴, 게시글 하단에 화면이 추가되어 출력됨.
  			- 댓글 등록 시 작성글의 줄바꿈, 공백생성, 태그사용 처리 필요
  			- fn사용을 위해 태그라이브러리 fn(jstl/functions)추가 필요 : header.jsp에 추가
  				> EL(Expression Language, 표현언어)
  				> JSTL(Jsp Standard Tag Library, 표준 태그 라이브러리)
  				
	- 2. ArrayList형식으로 리턴
		> 컨트롤러에서 뷰로 넘어가지 않고 그대로 데이터를 리턴
		> 뷰를 새로 구성할 필요는 없으나, 화면에서 데이터를 가공하여 출력(추가 코딩필요)
		
		> view.jsp
			==================================================================================================
			<script>
			$(function(){
				listReply2();
				
				//댓글 쓰기
				$("#btnReply").click(function(){
					...
					$.ajax({
						...
							listReply2(); // 댓글 목록 출력
						}
					});
				});
			});
			
			//댓글 목록 출력함수 2 : ArrayList를 받아 화면에서 코드로 구성
			function listReply2(){
				$.ajax({
					type: "get",
					contentType: "application/json",
					url: "${path}/reply/list_json.do?bno=${dto.bno}",
					success: function(result) {
						var output = "<table>";
						for(var i in result) {
							var repl = result[i].replytext;
							output += "<tr><td>" + result[i].name;
							output += "(" +result[i].regdate + ")";
							output += "<br>" + repl + "</td></tr>";
						}
						output +="</table>";
						$("#listReply").html(output);
					}
				});
			}
			</script>
			==================================================================================================

		> controller : list_json.do
			- 컨트롤러에서 ArrayList를 바로 리턴 --> js는 ArrayList형식이 없고, json객체배열로 받음
				: 추가한 라이브러리 jackson-databind가 데이터 형식을 변환 처리

		> 화면에서 표시되는 날짜값 형식변경, 공백문자, 줄바꿈, 태그무력화 : view.jsp에 관련 함수 작성
			==================================================================================================
			//댓글 목록 출력함수 2 : ArrayList를 받아 화면에서 코드로 구성
			function listReply2(){
				$.ajax({
					type: "get",
					contentType: "application/json",
					url: "${path}/reply/list_json.do?bno=${dto.bno}",
					success: function(result) {
						console.log(result);
						var output = "<table>";
						for(var i in result) {
							var repl = result[i].replytext;
							
				>>			repl = repl.replace(/</gi,"&lt;");			//태그문자 처리
				>>			repl = repl.replace(/>/gi,"&gt;");
				>>			repl = repl.replace(/  /gi,"&nbsp;&nbsp;");	//공백처리
				>>			repl = repl.replace(/\n/gi,"<br>");			//줄바꿈 처리
			
							output += "<tr><td>" + result[i].name;
							
				>>			//날짜값 변환
				>>			date = changeDate(result[i].regdate);
							
							output += "(" + date + ")";
							output += "<br>" + repl + "</td></tr>";
						}
						output +="</table>";
						$("#listReply").html(output);
					}
				});
			}
			
			//타임 스탬프값(숫자형)을 문자열로 변환
			function changeDate(date){
				date = new Date(parseInt(date));
				year =  date.getFullYear();
				
				month = date.getMonth();
				if(month < 9) {
					month += 1;
					month = "0" + month;
				} else {
					month += 1;
				}
				
				day = date.getDate();
				hour = date.getHours();
				minute = date.getMinutes();
				second = date.getSeconds();
				strDate = year + "-" + month + "-" + day + "-" + hour + ":" + minute + ":" + second;
				
				return strDate;
			}
			==================================================================================================
			> getMonth() : 달의 값은 인덱스 값으로, 1월 = 0으로 출력됨
			> 월의 인덱스를 받아 두자리수 처리와 인덱스를 해당월로 출력되도록 처리 필요.
			> / /gi : 정규표현식, Regular Expression. --> / /사이에 규칙 or 문자 처리
			
	** 정규표현식 ============================================================================================
	/ /gi : 정규표현식, Regular Expression
	
	/규칙/
	/규칙/gi : g=global(전역검색. 여러번 나오는 경우 포함), i=대소문자 무시 --> 해당규칙을 모두 찾아라
	===========================================================================================================
>>lec 19 51:00
	
	- 3. 글 목록 화면에서 댓글갯수 표시
		> boardMapper.xml : listAll에 서브쿼리 추가
		-------------------------------------------------------------------------------------------------------
		<!-- 레코드 목록조회 -->
		<select id="listAll" resultType = "com.example.spring02.model.board.dto.BoardDTO">
			SELECT R.*
				from (
					SELECT @rownum:=@rownum+1 AS rn, A.*
						from (
							select bno, title, writer, name, regdate, viewcnt,
		>>						(select count(*) from reply where bno = b.bno) cnt
						 	from board b, member m
						 	where b.writer=m.userid
						 	order by bno desc
					 	) A, (SELECT @rownum:=0) N
			) R WHERE R.rn BETWEEN #{start} AND #{end}
		</select>

		-------------------------------------------------------------------------------------------------------
			- (select count(*) from reply where bno = b.bno) cnt
				> cnt : alias. => 추가되는 컬럼의 이름
				> resultType에 기재된 DTO에 동일 이름의 필드가 있는지 확인필요.(값의 전달을 위해)
		
		> board/list.jsp 수정 : 댓글이 있는경우, cnt값 출력
			---------------------------------------------------------------------------------------------------
			...
			<td>
				<a href="${path}/board/view.do?bno=${row.bno}">${row.title }</a>
				<!-- 댓글 수 출력 -->
	>>			<c:if test="${row.cnt > 0}">
	>>				<span style="color:red;"> (${row.cnt })</span>
	>>			</c:if>
			</td>
			...
			---------------------------------------------------------------------------------------------------

>>lec 19 57:40 
 5) 게시물 수정, 삭제
  1> 게시물 삭제
  	- 게시글, 댓글, 첨부파일의 레코드와 첨부파일 모두 삭제 : 게시물이 있는경우 알림...
  	- 테이블이 외래키로 연결되어 있으므로, 댓글/첨부파일이 있는 게시물의 레코드를 삭제하면 sql오류 발생(500)
  		> 데이터 무결성 제약조건 에러발생
  	
  	- view.jsp : 삭제버튼 script - confirm()사용, delete.do로 요청
  	- BoardController : delete.do
  	- BoardService : delete()
  		> 트랜젝션 처리 : reply, attach, board레코드, 첨부파일을 모두 삭제
  		
  	- DAO : 각 table의 레코드를 삭제
  	- mapper
  		> boardMapper.xml
  			-------------------------------------------------------------------------------------------------
			<!-- 게시물 레코드 삭제 -->
			<delete id="delete">
				delete from board where bno=#{bno}
			</delete>
  			-------------------------------------------------------------------------------------------------

  2> 게시물을 삭제하지 않고 필드값을 변경하여 숨김처리 (데이터 보존)
  	- 댓글, 첨부파일 등의 정보를 지우기가 곤란하고, 복원등이 필요해질 경우를 대비하여 데이터를 보존한다.
  	- board table 수정 : 필드 추가
  		> ALTER TABLE `board` ADD `SHOW` CHAR(1) NOT NULL DEFAULT 'Y' 
>>  		(**mysql에서 필드와 테이블 이름에 back quote가 없으면 오류발생. show라는 예약어가 있음)
  	- boardMapper.xml 수정 : listAll수정, update태그 추가
  		-----------------------------------------------------------------------------------------------------
			<!-- 레코드 목록조회 -->
			<select id="listAll" resultType = "com.example.spring02.model.board.dto.BoardDTO">
				SELECT R.*
					from (
						SELECT @rownum:=@rownum+1 AS rn, A.*
							from (
								select bno, title, writer, name, regdate, viewcnt,
									(select count(*) from reply where bno = b.bno) cnt, 
			>>						 `show`
							 	from board b, member m
							 	where b.writer=m.userid
			>>				 	 and `show`='Y'
							 	order by bno desc
						 	) A, (SELECT @rownum:=0) N
				) R WHERE R.rn BETWEEN #{start} AND #{end}
			</select>
			
			...
			
			<!-- 게시물 숨김처리(삭제대신 사용) -->
			<update id="delete_record">
				update board set `show`='N' where bno=#{bno}
			</update>
  		-----------------------------------------------------------------------------------------------------
		> show필드의 값이 Y인 경우에만 목록으로 출력 : show필드 추가, 조건절에 and로 `show`='Y' 추가
		> show필드 값을 'N'으로 바꾸는 update태그 쿼리 추가(*delete태그에 쿼리를 작성하여도 쿼리대로 동작)
		> show는 예약어가 존재 --> back quote표시 필수
		
	- boardDAO : delete()수정
		-----------------------------------------------------------------------------------------------------
		//게시물 레코드 삭제 --> 숨김처리(필드값 업데이트)
		@Override
		public void delete(int bno) throws Exception {
			//sqlSession.delete("board.delete", bno);
			sqlSession.update("board.delete_record", bno);
		}
		-----------------------------------------------------------------------------------------------------
		
	** SQL --------------------------------------------------------------------------------------------------
	- mysql에서 예약어가 존재 : 필드이름을 동일하게 사용하여야 할 경우 back quote로 표시할 것
	- mybatis의 경우 <select>, <insert>, <delete>, <update> 태그가 존재. 태그 이름에 상관없이 쿼리가 수행된다
		> 즉, create table등을 사용하여야 하는 경우 등 해당 태그가 없더라도 어느 태그에서나 수행 가능하다. 
	---------------------------------------------------------------------------------------------------------
>> lec 19 1:16:00 
 
 6) 게시물 검색
 	- 기존의 리스트를 수정
 	- 페이지 나누기 : 검색 후 다른페이지로 이동하여도 검색목록이 유지되도록 처리
 		> map으로 옵션과 키워드를 전달 : list.jsp --> BoardController --> list.jsp
 	
  1> 검색폼 추가 : list.jsp
  	---------------------------------------------------------------------------------------------------------
	<!-- 검색폼 -->
	<form name="form1" method="post" action="${path }/board/list.do">
		<!-- 컨트롤러에서 받은 검색조건 값에 따라 option선택 -->
		<select name="search_option">
			<option value="name" <c:if test="${map.search_option == 'name' }">selected</c:if> >이름</option>
			<option value="title" <c:if test="${map.search_option == 'title' }">selected</c:if> >제목</option>
			<option value="content" <c:if test="${map.search_option == 'content' }">selected</c:if> >내용</option>
			<option value="all" <c:if test="${map.search_option == 'all' }">selected</c:if> >이름+제목+내용</option>
		</select>
		<!-- 컨트롤러에서 받은 키워드 값을 입력 -->
		<input name="keyword" value="${map.keyword }">
		<input type="submit" value="조회">
	</form>
	...
	<script>
	...
	function list(page){
		//location.href = "${path}/board/list.do?curPage="+page;
>>		location.href = "${path}/board/list.do?search_option=${map.search_option}"
>>						+"&keyword=${map.keyword}&curPage="+page;
	}
	</script>
  	---------------------------------------------------------------------------------------------------------
  	> search_option, keyword가 전달됨.
  	> 컨트롤러로 넘어갔던 검색조건들은 다시 반환 : 검색 후 화면이 전환되지만 검색조건과 키워드가 화면에 유지
  	> 목록의 페이지가 변하더라도 검색목록이 유지 : 페이지 이동 요청 시 요청값을 url의 파라미터에 포함
>>	> 페이지 이동 요청방식을 post로 바꾸어 변수값이 url에 표시되지 않도록 수정필요.  	
  
  2> 컨트롤러 : BoardController - list.do
  	---------------------------------------------------------------------------------------------------------
	@RequestMapping("list.do")	// 세부적인 url pattern
	public ModelAndView list(
>>			@RequestParam(defaultValue="name") String search_option,	//검색 옵션
>>			@RequestParam(defaultValue="") String keyword,				//검색 키워드
			@RequestParam(defaultValue="1") int curPage					//요청 페이지번호
		) throws Exception {
		
		//레코드 갯수 계산
		//int count = boardService.countArticle(); //전체 레코드 수
>>		int count = boardService.countArticle(search_option, keyword); //조건에 따른 레코드 수
		
		//페이지 관련 설정
		Pager pager = new Pager(count, curPage);
		int start =  pager.getPageBegin();
		int end = pager.getPageEnd();
		
		//List<BoardDTO> list = boardService.listAll(start, end);	// 게시물 목록
>>		List<BoardDTO> list = boardService.listAll(search_option, keyword, start, end);	// 조건에 따른 게시물 목록
		ModelAndView mav = new ModelAndView();
		HashMap<String, Object> map = new HashMap<>();
		
		map.put("list", list);		// map에 자료 저장
		map.put("count", count);	// 게시물 총 갯수
		
		map.put("pager", pager);	// 페이지 네비게이션을 위한 변수
		
		// 페이지 이동 시 검색결과가 초기화되지 않도록 값을 전달
>>		map.put("search_option", search_option);
>>		map.put("keyword", keyword);
		
		mav.setViewName("board/list"); // 포워딩할 view의 이름
		mav.addObject("map", map);	//ModelAndView에 map을 저장
		
		return mav; // board/list.jsp로 이동
	}
  	---------------------------------------------------------------------------------------------------------
	- 검색조건 없이 화면을 띄우는 경우(첫 목록 조회), 기본값이 없어 오류발생(400, bad request)
		> @RequestParam(defaultValue=기본값)으로 각 파라미터의 기본값을 설정해 준다.
	
  3> 서비스 : countArticle(), listAll()
  	---------------------------------------------------------------------------------------------------------
		@Override
	//	public List<BoardDTO> listAll(int start, int end) throws Exception {
		public List<BoardDTO> listAll(String search_option, String keyword, int start, int end) throws Exception {
			return boardDao.listAll(search_option, keyword, start, end);
		}
		
		//레코드 총 갯수
		@Override
	//	public int countArticle() throws Exception {
>>		public int countArticle(String search_option, String keyword) throws Exception {
	//		return boardDao.countArticle();
>>			return boardDao.countArticle(search_option, keyword);
		}
  	---------------------------------------------------------------------------------------------------------

  4> DAO : countArticle(), listAll()
  	---------------------------------------------------------------------------------------------------------
		// 게시물 목록 리턴
		@Override
	//	public List<BoardDTO> listAll(int start, int end) throws Exception {
		public List<BoardDTO> listAll(String search_option, String keyword, int start, int end) throws Exception {
			// Map<key의 자료형, value의 자료형>
			Map<String, Object> map = new HashMap<>();
			map.put("search_option", search_option);
			map.put("keyword", "%"+keyword+"%");
			map.put("start", start);
			map.put("end", end);
			// mapper에는 2개 이상의 값을 전달 할 수 없음(dto또는 map사용)
			return sqlSession.selectList("board.listAll", map);
		}
		
		//레코드 총 갯수
		@Override
	//	public int countArticle() throws Exception {
		public int countArticle(String search_option, String keyword) throws Exception {
	//		return sqlSession.selectOne("board.countArticle");
			
			// 조건검색
			Map<String, String> map = new HashMap<>();
			map.put("search_option", search_option);
			map.put("keyword", "%"+keyword+"%");
			return sqlSession.selectOne("board.countArticle", map);
		}
  	---------------------------------------------------------------------------------------------------------
	- 쿼리로 값을 요청 할 때, like옵션을 사용 : 대상이 되는 검색 키워드의 앞뒤는 "%"가 포함되어 있어야 함

  5> mapper : listAll 수정 - 검색옵션
  	- 쿼리에 조건 추가
  		=====================================================================================================
  		<!-- sql 태그 : 다른 query에 포함시킬 수 있는 조각 -->
		<!-- jstl의 choose문과 문법 동일 -->
		<sql id="search">
			<choose>
				<when test="search_option == 'all'">
					where b.writer = m.userid
						and `show`='Y'
						and (name like #{keyword} or title like #{keyword} or content like #{keyword})
				</when>
				<otherwise>
					where b.writer = m.userid
						and `show`='Y'
>>						and ${search_option} like #{keyword}
				</otherwise>
			</choose>
		</sql>
		
		<!-- 페이지 나누기 쿼리 앞뒤 -->
		<sql id = "paging_header">
			SELECT R.*
				from (
					SELECT @rownum:=@rownum+1 AS rn, A.*
						from (
		</sql>
		<sql id = "paging_footer">
							 	) A, (SELECT @rownum:=0) N
			) R WHERE R.rn BETWEEN #{start} AND #{end}
		</sql>
		
	
		<!-- 레코드 목록조회 -->
		<select id="listAll" resultType = "com.example.spring02.model.board.dto.BoardDTO">
			<include refid="paging_header" />
				select bno, title, writer, name, regdate, viewcnt,
					(select count(*) from reply where bno = b.bno) cnt, 
					 `show`
			 	from board b, member m
			 	<include refid="search" />
			 	order by bno desc
			<include refid="paging_footer" />
		</select>
  		
  		...
  		<!-- 레코드 총 갯수 계산, refid:다른 tag의 id -->
		<select id="countArticle" resultType="int">
			select count(*) from board b, member m
		>>	<include refid="search" />
		</select>
  		=====================================================================================================
  		> 정의된 부분 쿼리로 각 조건절을 대체 : <include refid="search" />
  		> 페이지 나누기 쿼리를 조각내어 정리
  		> mybatis ${}/#{}
  			- ${} : 파라미터가 바로 출력됨 = 테이블이나 컬럼명을 파라미터로 전달
  			- #{} : 파라미터가 String 형태로 들어와 '값'의 형태가 된다.

>> lec 19 종료.

lec20 ~

15. 도로명 주소

 1) 도로명 주소 사이트
 	- 행정자치부 http://www.juso.go.kr
 	- 개발자 센터에서 api신청 가능 (개발자센터 > 오픈api > api신청하기)
 		: http://www.juso.go.kr/addrlink/devAddrLinkRequestUse.do?menu=main&cPath=99JA
 	- 규칙에 맞게 url 요청 --> 해당 도로명주소 리턴

 2) 우편번호, 주소 서비스 방법
  1> 직접구축
	- 주소DB제공 > 도로명주소DB 다운로드 : DB를 다운로드 받아 활용. EXCEL에서 읽을 수 있는 파일형식
	- DB서버와 테이블을 미리 준비, 받은 DB를 import하여 사용
	- 텍스트 파일을 엑셀로 읽어 (구분자|) csv로 변환한 후 필요한 컬럼만 선택한 후 저장
	- import할 테이블을 미리 생성한 후 SQL Developer등 프로그램에서 import하여 테이블로 저장
	
	--> 개발시간이 오래걸림, 주기적 DB업데이트 필요

>> lec20 27:00 ~	
  2> API사용
  	- 다음 API : http://postcode.map.daum.net/guide
  	- 가이드 중 "사용자가 선택한 값 이용하기" 항목의 "예제코드보기" : js function 사용
  	
 3) API사용 예제
 	- url로 요청하여 주소리턴값을 받는다.
  1> menu.jsp : <a href= "${path}/member/address.do">도로명 주소</a>
  
  2> MemberController에 method추가 : 화면이동
	  --------------------------------------------------------------------------------------------------------
	  	@RequestMapping("address.do")
		public String address() {
			return "member/join";
		}
	  --------------------------------------------------------------------------------------------------------

  3> join.jsp : form을 생성하고, 예제코드의 javascript function을 사용
  
lec20 37:00
> note 10으로...